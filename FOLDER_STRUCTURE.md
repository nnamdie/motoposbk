# NestJS Project Folder Structure Template

This document outlines the standard folder structure for NestJS applications, designed to promote maintainability, scalability, and consistency across projects.
Important: ensure only one class or entity per file

## Root Structure

```
project-name/
├── src/                    # Source code directory
├── test/                   # Test files (if not co-located)
├── dist/                   # Compiled output (generated)
├── node_modules/           # Dependencies (generated)
├── uploads/                # File uploads directory
├── .env                    # Environment variables
├── .env.example           # Environment template
├── .gitignore             # Git ignore rules
├── package.json           # Project dependencies and scripts
├── package-lock.json      # Lock file (generated)
├── tsconfig.json          # TypeScript configuration
├── nest-cli.json          # NestJS CLI configuration
├── jest.config.ts         # Jest testing configuration
├── docker-compose.yml     # Docker services configuration
├── Dockerfile             # Docker container definition
└── README.md              # Project documentation
```

## Source Code Structure (`src/`)

```
src/
├── main.ts                # Application entry point
├── app.module.ts          # Root application module
├── app.service.ts         # Root application service
├── app.service.spec.ts    # Root service tests
├── config/                # Configuration files
│   ├── app.config.ts      # Application configuration
│   └── database.config.ts # Database configuration
├── common/                # Shared/common components
│   ├── common.module.ts   # Common module definition
│   ├── decorators/        # Custom decorators
│   │   └── current-user.decorator.ts
│   ├── entities/          # Base entities
│   │   └── base.entity.ts
│   ├── exceptions/        # Custom exceptions
│   │   └── base.exception.ts
│   ├── filters/           # Global exception filters
│   │   └── http-exception.filter.ts
│   ├── interceptors/      # Global interceptors
│   │   └── transform.interceptor.ts
│   ├── models/            # Shared DTOs and interfaces
│   │   ├── base-response.dto.ts
│   │   ├── paginated-query.dto.ts
│   │   └── validation-error.dto.ts
│   ├── pipes/             # Custom validation pipes
│   │   └── validation.pipe.ts
│   └── utils/             # Utility functions
│       └── helpers.ts
├── health/                # Health check module
│   ├── health.module.ts
│   ├── health.controller.ts
│   ├── health.service.ts
│   ├── health.service.spec.ts
│   └── models/
│       └── health-response.dto.ts
├── migrations/            # Database migrations (content will be generated by migration:generate command)
│   ├── Migration1_init.ts
│   └── Migration2_add_feature.ts
└── <module_name>/         # Feature modules (examples below)
```

## Feature Module Structure

Each feature module follows a consistent pattern:

```
<module_name>/
├── <module_name>.module.ts        # Module definition
├── controllers/                   # HTTP controllers
│   ├── <module_name>.controller.ts
├── services/                      # Business logic
│   ├── <service_name>.service.ts
├── entities/                      # Database entities
│   └── <module_name>.entity.ts
├── repositories/                  # Data access layer
│   └── <module_name>.repository.ts
├── models/                        # DTOs, request models, response models, etc.
│   ├── <model_name>.request.dto.ts
│   ├── <model_name>.response.dto.ts
│   └── <model_name>.dto.ts
├── enums/                         # Module-specific enums
│   └── <enum_name>.enum.ts
├── exceptions/                    # Module-specific exceptions
│   ├── <exception_name>.exception.ts
├── guards/                        # Module-specific guards (if needed)
│   └── <guard_name>-auth.guard.ts
├── strategies/                    # Authentication strategies (if needed)
│   └── <strategy_name>.strategy.ts
├── decorators/                    # Module-specific decorators (if needed)
│   └── <decorator_name>-permission.decorator.ts
├── factories/                     # Factory classes (if needed)
│   └── <factory_name>-factory.ts
└── README.md                      # Module documentation (optional)
```

## File Naming Conventions

### Controllers
- `*.controller.ts` - HTTP controllers
- `*.controller.spec.ts` - Controller tests

### Services
- `*.service.ts` - Business logic services
- `*.service.spec.ts` - Service tests

### Entities
- `*.entity.ts` - Database entities/models

### DTOs and Models
- `*.request.dto.ts` - Request models DTOs
- `*.response.dto.ts` - Response models
- `*.dto.ts` - General DTOs

### Exceptions
- `*.exception.ts` - Not found exceptions

### Guards and Strategies
- `*.guard.ts` - Authentication guards
- `*.strategy.ts` - Passport strategies

## Best Practices

1. **Module Organization**: Keep related functionality together in modules
2. **Separation of Concerns**: Controllers handle HTTP, services handle business logic
3. **Consistent Naming**: Use kebab-case for files and folders
4. **Test Co-location**: Keep test files next to the files they test
5. **Clear Dependencies**: Use dependency injection and clear module boundaries
6. **Documentation**: Include README files for complex modules
7. **Type Safety**: Use TypeScript interfaces and types throughout
8. **Validation**: Use class-validator decorators for DTO validation

## Migration Strategy

When adding new features:
1. Create a new module following the established pattern
2. Add necessary entities, DTOs, and services
3. Create database migrations for schema changes
4. Add tests for new functionality
5. Update the root module to include the new feature module

This structure provides a solid foundation for scalable NestJS applications while maintaining consistency and readability across the codebase. 